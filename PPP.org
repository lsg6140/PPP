* Header file
  #+begin_src C++ :tangle ./std_lib_facilities.h :main no
    #ifndef H112
    #define H112 020215L

    #include<iostream>
    #include<iomanip>
    #include<fstream>
    #include<sstream>
    #include<cmath>
    #include<cstdlib>
    #include<string>
    #include<list>
    #include<forward_list>
    #include<vector>
    #include<unordered_map>
    #include<algorithm>
    #include<array>
    #include<regex>
    #include<random>
    #include<stdexcept>

    using Unicode = long;

    using namespace std;

    struct Exit : runtime_error {
      Exit() : runtime_error("Exit"){}
    };

    inline void error(const string& s)
    {
      throw runtime_error(s);
    }

    inline void error(const string& s1, const string& s2)
    {
      error(s1+s2);
    }

    inline void error(const string& s, int i)
    {
      ostringstream os;
      os << s << ": " << i;
      error(os.str());
    }

    #endif //H112
  #+end_src

* Ch 6
*** Strategy
  - What should the program do in the user's point of view?
  - Try breaking the program into manageable parts.
  - Build a small, limited version of the program that solves a key part
*** Prototype
    - Expression: 2+2
      Result: 4
    - Expression: 2+2*3
      Result: 8
    - Logic of the program
      read_a_line
      calculate
      write_result
    - To compile the code block, tangle the code block and compile with
      ~SPC c C~ ~$ g++ ch6_1.cpp -std=c++14~.
      After compile, run the program in shell by
      ~SPC !~.
    #+begin_src C++ :includes " \"std_lib_facilities.h\" " :tangle tangled/ch6_1.cpp 
      cout<<"Expression: ";
      int lval = 0;
      int rval;
      char op;
      int res;
      cin>>lval>>op>>rval;  // read something like 1+3

      if (op=='+')
        res = lval+rval;  // addition
       else if(op=='-')
         res = lval-rval;  // subtraction

      cout<<"Result: "<<res<<'\n';
    #+end_src
*** Second version
    - Add multiplication and division
    - More than one operand (e.g. 1+2+3)
    - ~switch~: testing a value agianst many constants
    #+begin_src C++ :includes " \"std_lib_facilities.h\" " :tangle tangled/ch6_2.cpp
      cout<<"Expression\n";
      cout<<"add an 'x' to end expression: ";
      int lval = 0;
      int rval;
      cin>>lval;
      if(!cin) error("no first operand");
      for (char op;cin>>op;){
        if(op!='x') cin>>rval;
        if(!cin) error("no second operand");
        switch(op){
        case '+':
          lval+=rval;
          break;
        case '-':
          lval-=rval;
          break;
        case '*':
          lval*=rval;
          break;
        case '/':
          lval/=rval;
          break;
        default:
          cout<<"Result :"<<lval<<'\n';
          return 0;

        }

       }
      error("bad expression");

    #+end_src
*** Tokens
    A token is a sequence of characters that presents something we consider a unit.
    Kinds of tokens:
    - Floating-point-literals
    - Operators
    - Parentheses
*** Grammar
    Define the syntax of our input. Program implements the rules of grammar.
    - Expression:
       Term
       Expression "+" Term
       Expression "-" Term
    - Term:
       Primary
       Term "*" Primary
       Term "/" Primary
       Term "%" Primary
    - Primary
       Number
       "(" Expression ")"
    - Number
       Floating-point-literal
*** COMMENT Turning a grammar into code

    We need four functions
    - ~get_token()~: read characters and compose tokens using ~cin~
    - ~expression()~: deal with + and -, calls ~term()~ and ~get_token()~
    - ~term()~: deal with *, /, and %, calls ~primary()~ and ~get_token()~
    - ~primary()~: deal with numbers and parentheses, calls ~expression()~ and ~get_token()~
* COMMENT Ch 7
* Ch 8
** Summary
  - A declaration is a statement that introduces a name into a scope
  - A definition is a declaration that fully specifies the entity declared
  - A definition of a variable set aside memory so can't be defined twice
  - A declaration simply tells how a that name can be used
  - A declaration is just an interface and doesn't allocate memory
  - Something can be declared as often as you like if it's done consistently
  #+begin_src C++
    int x = 7;                      // definition
    extern int x;                   // declaration
    extern int x;                   // another declaration

    double sqrt(double);            // declaration
    double sqrt(double) {/*...*/};   // definition
    double sqrt(double);            // another declaration

    int sqrt(double);               // error!! inconsistency
  #+end_src

  #+RESULTS:

  - ~extern~ keyword states that declaration of ~x~ is not a definition
  - Avoid using ~extern~
  - A declaration supplies the type
  - A definition supplies the object (the memory)
  - A header should only contain declarations that can be duplicated in several files
  - ~(a>=b)?a:b~ is ~a~ if ~a>=b~ and ~b~ otherwise
  - Try to avoid class in function
  - Function within function is not allowed
  - Pass-by-const-reference: ex) ~const vector<double>& v~
  - Pass-by-reference: ex) ~vector<double>& v~
  - Technical point of reference
  #+begin_src C++ :main no
    #include <iostream>

    int main()
    {
      int i = 7;
      int& r = i;                   // r is a reference to i
      r = 9;                        // i becomes 9
      i = 10;
      std::cout << r << ' ' << i << '\n'; // write: 10 10
    }
  #+end_src

  #+RESULTS:
  : 10 10
  - Any use of ~r~ is a use of ~i~
  - Reference can be a convenient shorthand for some object
  - ~double& var = v[f(x)][g(y)];~
  - Non-const-reference is essential in
    - manipulating containers and other large objects
    - for functions that change several objects (function can have only one return value)
  - Argumnet checking and conversion
  #+begin_src C++ :main no
    #include <iostream>

    int main()
    {
      double x = 1.2;
      int x1 = x;                   // truncate x
      int x2 = int(x);
      int x3 = static_cast<int>(x); // explicit conversion

      std::cout << "x1 = " << x1 << ", x2 = " << x2
                << " ,x3 = " << x3 << std::endl;

      return 0;
    }
  #+end_src

  #+RESULTS:
  | x1 = 1 | x2 = 1 | x3 = 1 |
  - constexpr functions: evaluated by the compiler to avoid the same calculation done millions of times at run time
  - A constexpr function with constexpr arguments is evaluated by compiler
  - Construct the ~Date~ once only
  #+begin_src C++ 
    const Date& default_date()
    {
      static const Date dd(1970,1,1);
      return dd;
    }
  #+end_src
  - The ~static~ local variable is initialized only the first time its function is called
** Exercise
*** Drill 1
   #+name: my.h
   #+begin_src C++ :main no :tangle tangled/my.h
     extern int foo;
     void print_foo();
     void print(int);
   #+end_src
   #+name: my.cpp
   #+begin_src C++ :main no :tangle tangled/my.cpp
     #include "my.h"
     #include "std_lib_facilities.h"

     int foo;
     void print_foo()
     {
       cout << foo << endl;
     }

     void print(int i)
     {
       cout << i << endl;
     }
   #+end_src
   #+name: use.cpp
   #+begin_src C++ :main no :tangle tangled/use.cpp
     #include "my.h"

     int main()
     {
       foo = 7;
       print_foo();

       print(99);
     }
   #+end_src

*** Drill 2
    #+name: d2
    #+begin_src C++ :main no :tangle tangled/d2.cpp
      #include "std_lib_facilities.h"

      void swap_v(int a, int b)
      {
        int temp;
        temp = a;
        a = b;
        b = temp;
      }

      void swap_r(int& a, int& b)
      {
        int temp;
        temp = a;
        a = b;
        b = temp;
      }

      /*
      void swap_cr(const int& a, const int& b)
      {
        int temp;
        temp = a;
        a = b;
        b = temp;
      } */

      int main()
      {
        int x = 7;
        int y = 9;
        swap_v(x,y);
        cout << "x= " << x << ", y= " << y <<endl;
        swap_v(7,9);
        swap_r(x,y);
        cout << "x= " << x << ", y= " << y << endl;
        // swap_r(7,9); not compiled
        double xx = 7;
        double yy = 9;
        swap_v(xx,yy);
        // swap_r(xx,yy); not compiled
        cout << "xx= " << xx << ", yy= " << yy << endl;
      }
    #+end_src
    
*** Drill 3
    #+name: d3.cpp 
    #+begin_src C++ :main no :tangle tangled/d3.cpp
      #include "std_lib_facilities.h"

      namespace X {
        int var;
        void print() {
          cout << var << endl;
        }
      }

      namespace Y {
        int var;
        void print()
        {
          cout << var << endl;
        }
      }

      namespace Z {
        int var;
        void print()
        {
          cout << var << endl;
        }
      }

      int main()
      {
        X::var = 7;
        X::print();
        using namespace Y;
        var = 9;
        print();
        {
          using Z::var;
          using Z::print;
          var = 11;
          print();
        }
        print();
        X::print();
      }
    #+end_src
*** Ex 1
   Make the input stream an explicit parameter
   =double expresssion() --> double expression(Token_stream& ts)=
*** Ex 2
    #+name: ex2-08
    #+begin_src C++ :main no
      void print(const vector<int>& v, const string& name)
      {
        cout << v.size() << " values in " << name << endl;
        cout << '{' << v[0] <<", ";
        for (int i=1;i<v.size();++i) {
          if (i%5==0) cout << endl;
          cout << v[i];
          if (i<v.size()-1) cout << ", ";
        }
        cout << '}' << endl;
      }
    #+end_src

    #+RESULTS: ex2-08
*** Ex 3 
    #+name: ex3-08
    #+begin_src C++ :main no :results output
      #include "/home/lsg/Programming/PPP/std_lib_facilities.h"

      void print(const vector<int>& v, const string& name)
      {
        cout << v.size() << " values in " << name << endl;
        cout << '{' << v[0] <<", ";
        for (int i=1;i<v.size();++i) {
          if (i%5==0) cout << endl;
          cout << v[i];
          if (i<v.size()-1) cout << ", ";
        }
        cout << '}' << endl;
      }


      void fibonacci(const int x,const int y,vector<int>& v,const int n)
      {
        if (n<1) return;
        if (n>=1) v.push_back(x);
        if (n>=2) v.push_back(y);

        for (int i=2; i<n; ++i) {
          int k = v[i-2] + v[i-1];
          v.push_back(k);
        }
      }

      int main()
      {
        int x=1;
        int y=2;
        vector<int> v;
        int n=10;
        fibonacci(x,y,v,n);
        print(v,"fibonacci");

        return 0;
      }
    #+end_src

    #+RESULTS: ex3-08
    : 10 values in fibonacci
    : {1, 2, 3, 5, 8, 
    : 13, 21, 34, 55, 89}
    If the name of source code block is "main", there is no output of result. (I don't know why...)

*** Ex 7 
    #+name: ex07
    #+begin_src C++ :main no :tangle ch08/ex07.cpp
      #include "/home/lsg/Programming/PPP/std_lib_facilities.h"

      vector<string> name;
      vector<double> age;

      void read_name()
      {
        string s;
        for (int i=0; i<5; ++i) {
          cout << "Enter the name: ";
          cin >> s;
          for (int j=0; j<name.size(); ++j)
            if (s==name[j]) error("duplicate name: ", s);
          name.push_back(s);
        }
      }

      void store_age()
      {
        double d = 0;
        for (int i=0; i<name.size(); ++i) {
          cout << "Enter the age of " << name[i] << ": ";
          cin >> d;
          age.push_back(d);
        }
      }

      void print()
      {
        for (int i=0; i<name.size(); ++i)
          cout << '(' << name[i] << ", " << age[i] << ')' << endl;
      }

      int find_index(const vector<string>& v, const string& s)
      {
        for (int i=0; i<v.size(); ++i)
          if (s == v[i]) return i;
        error("name not found: ", s);
      }

      void sort_age(const vector<string>& cp)
      {
        vector<double> copy_age;
        int index;
        for (int i=0; i<name.size(); ++i){
          index = find_index(cp, name[i]);
          copy_age.push_back(age[index]);
        }
        age = copy_age;
      }

      int main()
      try
        {
          read_name();
          vector<string> copy_name = name;
          store_age();
          print();

          sort(name.begin(),name.end());

          sort_age(copy_name);

          print();

          return 0;
        }
       catch(exception& e) {
         cerr << e.what() << endl;
         return 1;
       }

       catch(...) {
         cerr << "Unkown exception\n";
         return 2;
       }
    #+end_src
  
* Ch 9
** Summary
   - Types are helpful in
    - Representation: A type "knows" how to represent the data needed in an object
    - Operations: A type "knows" what operations can be applied to objects
   - The result of the operation depends on the data - the current state - of an object
   - User-defined types of C++
    - Class
    - Enumeration
   - Members: The parts used to define the class
   - ~m~ in ~mf(int)~ refers to ~var.m~
   #+begin_example
     class X {
     public:
       int m;
       int mf(int v) {int old = m; m = v; return old}
     };
   #+end_example
   - Interface is that its users access directly (~public:~)
   - Implementation is that its users access only indirectly through the interface (~private:~)
   - ~struct~ is a class where members are public by default
   - A member function with the same name as its class is the constructor
   - From C++11, ~{}~ is prefered than ~()~
   - A rule for what constitutes a valid value is called and /invariant/
   - If we can't think of a good variant, we are probably dealing with plain data and better to use a =stuct=
   - Definition of a member function within the class definition
     - The function will be inline
   - A class member function has an implicit argument which is uses to identify the object for which is is called
   - An =enum= is a very simple user-defined type, specifying its set of values as symbolic constants
   - We can assign an object to an int in plain enumeration
   - Plain =enum= is less strict than =enum class=
   - Prefer to use =enum class=
   - Operator overloading: +,-,*,/,%,[],(),^,!,&,<,<=,>,>=
   - Class interfaces
     - Keep interface complete
     - Keep interface minimal
     - Provide constructor
     - Support copying
     - Use type to provide good argument checking
     - Identify nonmodifying member functions
     - Free all resources in the destructor
   - In-class initializer: specified as part of the memeber declaration
   - Operations that do not modify the object can be invoked for =const= objects
   - Helper function is a design concept, not a programming language concept
   - Namespaces are often used to identify a group of helper functions
*** Date class 
    #+name: chrono.h
    #+begin_src C++ :main no :tangle ch10/chrono.h
      namespace Chrono {
        enum class Month {
                          Jan=1,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec
        };

        class Date {
        public:
          class Invalid();              // to be used as exception
          Date(int y, Month m, int d);
          Date();                       // default constructor
          Date(int y);

          // nonmodifying operations
          int month() const {return m;}
          int day() const {return d;}
          int year() const {return y;}

          // modifying operations
          void add_day(int n);
          void add_month(int n);
          void add_year(int n);
        private:
          int y;
          Month m;
          int d;
        };

        //------------------------------------------------------------

        void init_day(Date& dd, int y, int m, int d);

        //------------------------------------------------------------

        bool is_date(int y,Month m,int d);

        //------------------------------------------------------------

        bool leapyear(int y);

        //------------------------------------------------------------

        int month_to_day(Date::Month m);

        // ------------------------------------------------------------

        bool operator==(const Date& a,const Date& b);
        bool operator!=(const Date& a,const Date& b);

        ostream& operator<<(ostream& os,const Date& d);
        istream& operator>>(istream& is, Date& dd);

        //------------------------------------------------------------

        Day day_of_week(const Date& d);
        Date next_Sunday(const Date d);
        Date next_weekday(const Date& d);
      }

    #+end_src

    #+RESULTS: chrono.h

    #+name: chrono.c
    #+begin_src C++ :main no :tangle ch10/chrono.cpp
      #include "chrono.h"

      namespace Chrono {
        // construtors
        Date::Date(int yy,Month mm,int dd)
          :y{yy},m{mm},d{dd}
        {
          if (!is_date(yy,mm,dd)) throw Invalid{};
        }

        const Date& default_date()
        {
          static Date dd{2001,Month::Jan,1};
          return dd;
        }

        Date::Date()
          :y{default_date().year()},
           m{default_date().month()},
           d{defualt_date().day()}
        {}

        // member functions

        void Date::add_day(int n)
        {
          int dd = d+n;
          int years = dd/365;
          int days = dd%365;
          add_year(years);
          add_month(days);
        }

        void Date::add_month(int n)
        {
          // ...
        }

        void Date::add_year(int n)
        {
          if (m==Month::Feb&&d==29&&!leapyear(y+n)){
            m = Month::mar;
            d = 1;
          }
          y += n;
        }

        // helper functions

        bool is_date(int y,Month m,int d)
        {
          if (d<=0) return false;
          if (m<Month::Jan||Month::Dec<m) return false;

          int days_in_month = 31;

          switch (m){
          case Month::Feb:
            days_in_month = (leapyear(y))? 29:28;
            break;
          case Month::Apr: case Month::Jun: case Month::Sep: case Month::Nov:
            days_in_month = 30;
            break;
          }

          if (days_in_month<d) return false;

          return true;
        }

        // ------------------------------------------------------------

        bool leapyear(int y)
        {
          // ...
        }

        // ------------------------------------------------------------

        int month_to_days(Date::Month m)
        {
          switch (m) {
          case Month::Jan: return 0;
          case Month::Feb: return 31;
          case Month::Mar: return 31+28;
          case Month::Apr: return 31+28+31;
          case Month::May: return 31+28+31+30;
          case Month::Jun: return 31+28+31+30+31;
          case Month::Jul: return 31+28+31+30+31+30;
          case Month::Aug: return 31+28+31+30+31+30+31;
          case Month::Sep: return 31+28+31+30+31+30+31+31;
          case Month::Oct: return 31+28+31+30+31+30+31+31+30;
          case Month::Nov: return 31+28+31+30+31+30+31+31+30+31;
          case Month::Dec: return 31+28+31+30+31+30+31+31+30+31+30;
          }
        }

        // ------------------------------------------------------------

        int day_in_year(const Date& d)
        {
          int diy = month_to_days(d.month());
          diy += d.day();
          if (leapyear(d.year()) && d.month()>Date::feb) ++diy;
          return diy;
        }

        // ------------------------------------------------------------

        int n_leapyears(int y)
        {
          // leap years from 1970
          int nl = 0;
          for (int i=1970;i<y;++i)
            if (leapyear(y)) ++nl;
          return nl;
        }

        int days_linear(const Date& d)
        {
          if (d.year()<first_date.year()) error("days_linear(): year must be 1970 or later");
          int y = d.year() - first_date.year();
          return y*365 + n_leapyears(d.year()) + day_in_year(d) - 1;
        }

        // ------------------------------------------------------------

        bool operator==(const Date& a,const Date& b)
        {
          return a.year()==b.year()&&a.month()==b.month()&&a.day()==b.day();
        }

        bool operator!=(const Date& a,const Date& b)
        {
          return !(a==b);
        }

        ostream& operator<<(ostream& os,const Date& d)
        {
          return os<<'('<<d.year()
                   <<','<<int(d.month())
                   <<','<<d.day()<<')';
        }

        istream& operator>>(istream& is,const Date& dd)
        {
          int y, m, d;
          char ch1, ch2, ch3, ch4;
          is>>ch1>>y>>ch2>>m>>ch3>>d>>ch4;
          if (!is) return is;
          if (ch1!='('||ch2!=','||ch3!=','||ch4!=')'){
            is.clear(ios_base::failbit);
            return is;
          }

          dd = Date{y,Month{m},d};

          return is;
        }

        // ------------------------------------------------------------

        enum class Day {
                        Sun,Mon,Tue,Wed,Thu,Fri,Sat
        };

        Day day_of_week(const Date& d)
        {
          // ...
        }

        // ------------------------------------------------------------

        Date next_Sunday(const Date& d)
        {
          // ...
        }

        // ------------------------------------------------------------

        Date next_weekday(const Date& d)
        {
          // ...
        }
      } // Chrono
    #+end_src
* Ch 10
** Summary
   #+name: reading
   #+begin_src C++ :main no :tangle ch10/reading.cpp
     #include "std_lib_facilities.h"

     struct Reading {
       int hour;
       double temperature;
     };

     int main()
     {
       cout << "Please enter input file name: ";
       string iname;
       cin >> iname;
       ifstream ist{iname};
       if (!ist) error("can't open input file ",iname);

       string oname;
       cout << "Please enter name of output file: ";
       cin >> oname;
       ofstream ost{oname};
       if (!ost) error("can't open output file ",oname);

       vector<Reading> temps;
       int hour;
       double temperature;
       while (ist>>hour>>temperature) {
         if (hour<0||23<hour) error("hour out of range");
         temps.push_back(Reading{hour,temperature});
       }

       for (int i=0;i<temps.size();++i)
         ost<<'('<<temps[i].hour<<','<<temps[i].temperature<<")\n";
     }
   #+end_src

   I/O error handling
    stream states
    - =good()=: The operations succeeded
    - =eof()=: We hit end of input
    - =fail()=: Something unexpected happened
    - =bad()=: Something unexpected and serious happened
   Throwing error by =istream=.
   =ist.exceptions(ist.exceptions()|ios_base::badbit);=

   #+name: fill_vector
   #+begin_src C++ :main no
     void fill_vector(istream& ist,vector<int>,char terminator)
     {
       for (int i;ist>>i;) v.push_back(i);
       if (ist.eof()) return;

       ist.clear();

       char c;
       ist >> c;
       if (c!=terminator) {
         ist.unget();
         ist.clear(ios_base::failbit); // set the state to fail()
       }
     }
   #+end_src

   Breaking the problem into manageble parts
    - Reading values
    - Prompting the users for input
    - Writing error messages
    - Skipping past "bad" input characters
    - Testing the input against a range
      #+name: error-handling
      #+begin_src C++ :main no
        void skip_to_int()
        {
          if (cin.fail()) {
            cin.clear();

            for (char ch;cin>>ch;) {
              if(isdigit(ch)||ch=='-') {
                cin.unget();
                return;
              }
            }
          }
          error("no input");
        }

        int get_int()
        {
          int n = 0;
          while (true) {
            if (cin>>n) return n;
            cout << "Sorry, that was not a number; please try again\n";
            skip_to_int();
          }
        }

        int get_int(int low,int high)
        {
          cout << "Please enter an integer in the range"
               << low << " to " << high << " (inclusive):\n";

          while (true) {
            int n = get_int();
            if (low<=n&&n<=high) return n;
            cout << "Sorry"
                 << n << " is not in the [" << low << ":" << high
                 << "] range; please try again\n";
          }
        }
      #+end_src

   Reading a structured file
   #+name: reading_temp
   #+begin_src C++ :main no :tangle reading_temp.cpp
     #include "std_lib_facilities.h"

     const int not_a_reading = -7777;
     const int not_a_month = -1;
     constexpr int implausible_min = -200;
     constexpr int implausible_max = 200;

     vector<string> month_input_tbl = {
                                       "jan","feb","mar","apr","may","jun",
                                       "jul","aug","sep","oct","nov","dec"
     };

     // ------------------------------------------------------------

     struct Day {
       vector<double> hour {vector<double>(24,not_a_reading)};
     };

     struct Month {
       int month {not_a_month};
       vector<Day> day{32};
     };

     struct Year {
       int year;
       vector<Month> month{12};
     };

     struct Reading {
       int day;
       int hour;
       double temperature;
     };

     //------------------------------------------------------------

     istream& operator>>(istream& is,Reading &r)
     // format: (3 4 9.7)
     // check format, but don't bother with data validity
     {
       char ch1;
       if (is>>ch1&&ch1!='(') {
         is.unget();
         is.clear(ios_base::failbit);
         return is;
       }

       char ch2;
       int d;
       int h;
       double t;
       is>>d>>h>>t>>ch2;
       if(!is||ch2!=')') error("bad reading");
       r.day = d;
       r.hour = h;
       r.temperature = t;
       return is;
     }

     //------------------------------------------------------------

     istream& operator>>(istream& is, Month& m)
     // format: {month feb ...}
     {
       char ch = 0;
       if (is>>ch&&ch!='{') {
         is.unget();
         is.clear(ios_base::failbit);
         return is;
       }

       string month_marker;
       string mm;
       is >> month_marker >> mm;
       if (!is||month_marker!="month") error("bad start of month");
       m.month = month_to_int(mm);

       int duplicates = 0;
       int invalids = 0;
       for (Reading r;is>>r;){
         if (is_valid(r)) {
           if (m.day[r.day].hour[r.hour]!=not_a_reading)
             ++duplicates;
           m.day[r.day].hour[r.hour] = r.temperature;
         }
         else
           ++invalids;
       }
       if (invalids) error("invalid readings in month",invalids);
       if (duplicates) error("duplicate readings in month",duplicates);
       end_of_loop(is,'}',"bad end of month");
       return is;
     }

     //------------------------------------------------------------

     istream& operator>>(istream& is,Year& y)
     // format: {year 1972...}
     {
       char ch;
       is >> ch;
       if (ch!='{') {
         is.unget();
         is.clear(ios::failbit);
         return is;
       }

       string year_marker;
       int yy;
       is >> year_marker >> yy;
       if (!is||year_marker!="year") error("bad start of year");
       y.year = yy;

       while(true) {
         Month m;
         if(!(is>>m)) break;
         y.month[m.month] = m;
       }

       end_of_loop(is,'}',"bad end of year");
       return is;
     }

     //------------------------------------------------------------

     bool is_valid(const Reading& r)
     {
       if (r.day<1||31<r.day) return false;
       if (r.hour<0||23<r.hour) return false;
       if (r.temperature<implausible_min||implausible_max<r.temperature)
         return false;
       return true;
     }

     // ------------------------------------------------------------

     int month_to_int(string s)
     {
       for (int i=0;i<12;++i) if (month_input_tbl[i]==s) return i;
       return -1;
     }

     // ------------------------------------------------------------

     int main()
     {
       cout << "Please enter input file name: ";
       string iname;
       cin >> iname;
       ifstream ifs{iname};
       if(!ifs) error("can't open input file",iname);

       ifs.exceptions(ifs.exceptions()|ios_base::badbit);

       cout << "Please enter output file name: ";
       string oname;
       cin >> oname;
       ofstream ofs{oname};
       if (!ofs) error("can't open output file",oname);

       vector<Year> ys;
       while (true) {
         Year y;
         if (!(ifs>>y)) break;
         ys.push_back(y);
       }

       cout << "read " << ys.size() << " years of readings\n";

       for(Year& y : ys) print_year(ofs,y);
     }
   #+end_src
   
   We have to use the =()= initializer syntax to specify the number of elements for a =vector= for which an integer can be converted to the element type.
** Exercise
*** Drill 1
    #+name: d1
    #+begin_src C++ :main no :tangle ch10/drill01.cpp
      #include "/home/lsg/Programming/PPP/std_lib_facilities.h"

      struct Point {
        double x;
        double y;

        Point() :x{0},y{0}{}
        Point(double xx,double yy) :x{xx},y{yy} {}
      };

      ostream& operator<<(ostream& os, const Point& p)
      {
        os << '(' << p.x << ',' << p.y << ')';
      }

      istream& operator>>(istream& is, Point& p)
      {
        double xx,yy;
        char ch1,ch2,ch3;
        is>>ch1>>xx>>ch2>>yy>>ch3;
        if (!is) return is;
        if (ch1!='('||ch2!=','||ch3!=')') {
          is.clear(ios_base::failbit);
          return is;
        }
        p = Point{xx,yy};
        return is;
      }

      bool operator==(const Point& p1, const Point& p2)
      {
        return (p1.x==p2.x&&p1.y==p2.y);
      }

      bool operator!=(const Point& p1, const Point& p2)
      {
        return !(p1==p2);
      }

      void print(const vector<Point>& p)
      {
        for (int i=0; i<p.size(); ++i) {
          cout << p[i] << endl;
        }
      }

      void fprint(const vector<Point>& p, const string& s)
      {
        ofstream ost{s};
        if (!ost) error("can't open output file ",s);
        for (int i=0; i<p.size(); ++i) {
          ost << p[i] << endl;
        }
      }

      void read_from_file(vector<Point>& point, const string& filename)
      {
        ifstream ist{filename};
        if (!ist) error("can't open input file, ",filename);

        for (Point p; ist>>p;) 
          point.push_back(p);
      }

      void compare_vectors(const vector<Point>& p1, const vector<Point>& p2)
      {
        if (p1.size()!=p2.size()) error("Something's wrong");
        for (int i=0; i<p1.size(); ++i) {
          if (p1[i]!=p2[i])
            error("Something's wrong");
        }
        cout << "Two vectors are identical" << endl;
      }

      int main()
      try {
        vector<Point> original_points;
        double xx;
        double yy;
        int i=0;
        while(cin>>xx>>yy){
          ++i;
          original_points.push_back(Point{xx,yy});
          if (i>6) break;
        }

        string filename = "mydata.txt";
        fprint(original_points,filename);


        vector<Point> processed_points;

        read_from_file(processed_points,filename);

        compare_vectors(original_points, processed_points);
        return 0;
      }

       catch(exception& e) {
         cerr << "exception: " << e.what() << endl;
         return 1;
       }
       catch(...) {
         cerr << "Unkown exception\n";
         return 2;
       }
    #+end_src

*** Ex 1
    #+begin_src conf :tangle ch10/integers.txt
      10 20 30 40
    #+end_src

    #+name: ex01
    #+begin_src C++ :main no
      // sum of whitespace seperated integers in a file
      #include "/home/lsg/Programming/PPP/std_lib_facilities.h"

      int main()
      {
        const string& filename = "/home/lsg/Programming/PPP/ch10/integers.txt";

        ifstream ifs{filename};
        if(!ifs) error("can't open the file, ",filename);

        int n;
        vector<int> numbers;
        while(ifs>>n) {
          numbers.push_back(n);
        }

        for(int i : numbers)
          cout << i << ' ';
        cout << endl;

        int sum;
        for(int i : numbers)
          sum += i;
        cout << "sum is " << sum << endl;

      }
    #+end_src

    #+RESULTS: ex01
    : Lines containing a word: file
    : Line 1: This is The Input file    for the Lower case OUTPUT

*** Ex 2
    #+name: ex02
    #+begin_src C++ :main no :tangle ch10/store_temps.cpp
      #include "../std_lib_facilities.h"

      struct Reading {
        int hour;
        double temperature;
      };

      istream& operator>>(istream& is,Reading& r)
      {
        int h;
        double t;
        is >> h >> t;
        if(!is) return is;

        r = Reading{h,t};

        return is;
      }

      ostream& operator<<(ostream& os,const Reading& r)
      {
        int h = r.hour;
        double t = r.temperature;
        os << h << ' ' << t;
        return os;
      }

      void fill_reading(istream& ist, vector<Reading>& v, char terminator)
      {
        for (Reading r; ist>>r;) v.push_back(r);
        if (ist.eof()) return;

        if (ist.bad()) error("ist is bad");
        if (ist.fail()) {
          ist.clear();

          char c;
          ist >> c;
          if (c!=terminator) {
            ist.unget();                  // put the character back
            ist.clear(ios_base::failbit); // set the state to fail()
          }
        }
      }

      void write_file(const vector<Reading>& v, string filename)
      {
        ofstream ofs{filename};
        if (!ofs) error("can't open the file ",filename);

        for (Reading r : v)
          ofs << r << endl;
      }

      const int min_temp = -43;
      const int max_temp = 107;

      Reading random_reading()
      // creates n random temperatures
      {
        int h = rand()%24;
        double t = min_temp + (double)rand()/RAND_MAX*(max_temp-min_temp);
        return Reading{h,t};
      }


      int main()
      try {
        vector<Reading> temps;
        char terminator = 't';
        // cout << "Enter hour and temperature" << endl;
        // cout << "type '" << terminator << "' to finish input" << endl;
        // fill_reading(cin,temps,terminator);
        for (int i=0; i<50; ++i)
          temps.push_back(random_reading());

        string filename = "raw_temps.txt";

        write_file(temps,filename);

        return 0;
      }

       catch(exception& e) {
         cerr << "exception error " << e.what();
         return 1;
       }

       catch(...) {
         cerr << "unkown exception";
         return 2;
       }
    #+end_src

    #+RESULTS: ex02
* Ch 11 
** Summary
  - Output precision: =setprecision(int n)=
  - Output field width: =setw(int n)=
  - Binary I/O: When we move from charater-oriented I/O to binary I/O, we give up our usual =>>= and =<<= operators.
    =ostream ofs{oname,ios_base::binary}=
    =for(int x : v) ofs.write(as_byte(x),sizeof(int))=
    #+name: punc_stream
    #+begin_src C++ :main no
      #include "../std_lib_facilities.h"

      class Punct_stream {
      public:
        Punct_stream(istream& is)
          :source{is},sensitive{true} {}

        void whitespace(const string& s) {white = s;}
        void add_white(char c) {white += c;}
        bool is_whitespace(char c);
        void case_sensitive(bool b) {sensitive = b};
        bool is_case_sensitive() {return sensitive};

        Punct_stream& operator>>(string& s);
        operator bool();

      private:
        istream& source;              // character source
        istringstream buffer;         // let buffer do our formatting
        string white;                 // charaters considered whitespace
        bool sensitive;
      };

      Punct_stream& Punct_stream::operator>>(string& s)
      {
        while (!(buffer>>s)) {
          if (buffer.bad()||!source.good()) return *this;
          buffer.clear();

          string line;
          getline(source,line);

          for (char& ch : line) {
            if (is_whitespace(ch))
              ch = ' ';
            else if (!sensitive)
              ch = tolower(ch);
          }

          buffer.str(line);           // put string into stream
          // set the istringstream buffer's string to line
        }
        return *this;
        // *this is a reference to the stream itself
      }

      bool Punct_stream::is_whitespace(char c)
      {
        for (char w : white)
          if (c==w) return true;
        return false;
      }

      Punct_stream::operator bool()
      {
        return !(source.fail()||source.bad())&&buffer.good();
      }

    #+end_src

    #+RESULTS: punc_stream

** Exercise
*** Drill
    #+name: test_output
    #+begin_src C++ :main
      #include "/home/lsg/Programming/PPP/std_lib_facilities.h"

      void print_float(double d)
      {
        cout << "defaultfloat:\t" << d << endl
             << "fixed:\t" << fixed << d << endl
             << "scientific:\t" << scientific << d << endl;
      }
      int main()
      {
        int birth_year = 1979;

        cout << "Decimal: " << '\t' << birth_year << endl
             << "Hexadecimal: " << '\t' <<hex << birth_year << endl
             << "Octal: " << '\t' << oct << birth_year << endl;

        double d = 1234567.89;
        print_float(d);

        return 0;
      }
    #+end_src

    #+RESULTS: test_output
    | Decimal:      |         1979 |
    | Hexadecimal:  |          7bb |
    | Octal:        |         3673 |
    | defaultfloat: |  1.23457e+06 |
    | fixed:        |   1234567.89 |
    | scientific:   | 1.234568e+06 |

    #+name: d8
    #+begin_src C++ :main no :tangle ch11/drill08.cpp
      #include "../std_lib_facilities.h"

      int main()
      {
        int a,b,c,d;

        cin >> a >> oct >> b >> hex >> c >> d;
        cout << a << '\t' << b << '\t' << c << '\t' << d << endl;

        return 0;
      }
    #+end_src

   - Manipulator: Terms that are used to change the behavior of a stream
   - Fields: A mechainsm for integer to control the space a value takes up. (set field width) =setw()=

*** Ex1
    #+begin_src conf :tangle ch11/input.txt
      This is The Input file,,, for the Lower case OUTPUT!!.
      Multiline works?????
    #+end_src

    #+name: ex01
    #+begin_src C++ :main no :tangle ch11/ex01.cpp :results output
      #include "/home/lsg/Programming/PPP/std_lib_facilities.h"

      void copy_to_lower(const string& iname,const string& oname)
      {
        ifstream ist{iname};
        if (!ist) error("can't open the file ",iname);

        ofstream ost{oname};
        if (!ost) error("can't open the file ",oname);

        char ch;
        while (ist.get(ch)) {
          if (isalpha(ch)) ch = tolower(ch);
          ost << ch;
        }
      }

      vector<string> words_in_line(string& line)
      {
        for (char& ch : line)
          switch (ch) {
          case ';': case '.': case ',': case '?': case '!':
            ch = ' ';
          }

        stringstream ss{line};
        vector<string> vs;
        for (string word; ss>>word;)
          vs.push_back(word);
        return vs;
      }

      void find_word(const string& iname,const string& s)
      {
        ifstream ist{iname};
        if (!ist) error("can't open the file ",iname);

        int i=0;
        string line;

        cout << "Lines containing a word: " << s << endl;
        while (getline(ist,line)) {
          ++i;
          vector<string> words = words_in_line(line);
          for (int j=0; j<words.size(); ++j) {
            if (words[j] == s)
              cout << "Line " << i << ": " << line << endl;
          }
        }
      }

      int main()
        try {
          string iname = "/home/lsg/Programming/PPP/ch11/input.txt";
          string oname = "/home/lsg/Programming/PPP/ch11/output.txt";

          copy_to_lower(iname,oname);

          find_word(iname,"file");
        }
        catch(exception& e) {
          cerr << "Exception: " <<e.what();
          return 1;
        }
        catch(...) {
          cerr << "Unkown exception";
          return 2;
        }
    #+end_src

    #+name: ex09
    #+begin_src C++ :main no :tangle ch11/ex09.cpp
      #include "/home/lsg/Programming/PPP/std_lib_facilities.h"

      vector<string> split(const string& s)
      {
        istringstream is{s};
        vector<string> vs;
        string buf;
        while (is>>buf)
          vs.push_back(buf);
        return vs;
      }

      vector<int> spliti(const string& s)
      {
        vector<int> res;
        bool in_word = false;
        for (int i=0; i<s.size(); ++i) {
          if (isspace(s[i]))
            in_word = false;
          else {
            if (!in_word)
              res.push_back(i);
            in_word = true;
          }
        }
        return res;
      }

      void print_word1(const string& s,int i)
      {
        for (;i<s.size()&&!isspace(s[i]); ++i)
          cout << s[i];
        cout << ' ';
      }

      int main()
      {
        cout << "Please enter a line:\n";

        string line;
        while (getline(cin,line)) {
          cout << "line:\n" << line << endl;

          vector<string> ln1 = split(line);
          cout << "words in line:\n";
          for (int i=0;i<ln1.size();++i)
            cout << ln1[i] << ' ';
          cout << endl;

          vector<int> ln2 = spliti(line);
          cout << "words in line:\n";
          for (int i=0;i<ln2.size();++i)
            print_word1(line,ln2[i]);
          cout << endl;

          cout << "Please enter another line:\n";
        }
      }
    #+end_src
* A Display Model
  use FLTK used in this book, FLTK library was installed in Ubuntu 18.04 (at 28th Feb 2019) by =sudo apt install libfltk1.3-dev=.
*** Issue 1 in compiling libbookgui.a
  To compile the next example, GUI libraries used in book should be compiled to archive file =libbookgui.a=. Source code in =GUI= folder provided by Stroustrup has some issue. When excute =make= in =GUI= folder, compiler complains about ambiguity of reference to 'Window' in =Simple_window.h=. To fix this problem, =struct Simple_window : Window= in 17th line of =Simple_window.h= was changed to =struct Simple_window : Graph_lib::Window=. I am not sure why =using namespace Graph_lib= does not solve this issue. 
*** Issue 2 in compiling libbookgui.a
  Function =bool Graph_lib::can_open(const string&)= in =Graph.cpp= produced error of wrong return type. (I am not sure why...) I modified this function as 
  #+name: modification of can_open
  #+begin_src C++ :main no
    bool can_open(const string& s)
    {
      ifstream ff(s.c_str());
      if (ff) return true;
      return false;
    }
  #+end_src

  To compile the next example, library for image related functions should be included to make =Fl_JPEG_Image= function work. Compile was done with flags such that =g++ guiex.cpp libbookgui.a -lfltk -lfltk_images=.
*** TODO How to run C++ source code in emacs that should be compiled with other object files??
  #+name: gui example
  #+begin_src C++ :main no :tangle ch12/guiex.cpp :flags -lfltk -lfltk_images
    #include "/home/lsg/Programming/PPP/GUI/Simple_window.h"
    #include "/home/lsg/Programming/PPP/GUI/Graph.h"

    int main()
    {
      using namespace Graph_lib;

      Point tl{100,100};

      Simple_window win{tl,600,400,"Canvas"};

      Polygon poly;

      poly.add(Point{300,200});
      poly.add(Point{350,100});
      poly.add(Point{400,200});

      poly.set_color(Color::red);

      win.attach(poly);

      win.wait_for_button();
    }
  #+end_src

  #+RESULTS: gui example

  #+name: display
  #+begin_src C++ :main no :tangle ch12/dispaly.cpp
    #include "../GUI/Simple_window.h"
    #include "../GUI/Graph.h"
    #include <iostream>
    #include <stdexcept>

    using namespace std;
    using namespace Graph_lib;

    int main()
      try{
        Point tl{100,100};

        Simple_window win{tl,600,400,"Canvas"};

        Axis xa{Axis::x,Point{20,300},280,10,"x axis"};
        win.attach(xa);
        win.set_label("Canvas #2");

        Axis ya{Axis::y,Point{20,300},280,10,"y axis"};
        ya.set_color(Color::cyan);
        ya.label.set_color(Color::dark_red);
        win.attach(ya);
        win.set_label("Canvas #3");

        Function sine{sin,0,100,Point{20,150},1000,50,50};
        // range[0:100) start at (20,150)
        // using 1000 points, scale x and y *50
        win.attach(sine);
        win.set_label("Canvas #4");
        sine.set_color(Color::blue);

        Polygon poly;
        poly.add(Point{300,200});
        poly.add(Point{350,100});
        poly.add(Point{400,200});

        poly.set_color(Color::red);
        poly.set_style(Line_style::dash);
        win.attach(poly);
        win.set_label("Canvas #5");

        Rectangle r{Point{200,200},100,50};
        win.attach(r);
        win.set_label("Canvas #6");

        Closed_polyline poly_rect;
        poly_rect.add(Point{100,50});
        poly_rect.add(Point{200,50});
        poly_rect.add(Point{200,100});
        poly_rect.add(Point{100,100});
        win.attach(poly_rect);

        poly_rect.add(Point{50,75});

        r.set_fill_color(Color::yellow);
        poly.set_style(Line_style(Line_style::dash,4));
        poly_rect.set_style(Line_style(Line_style::dash,2));
        poly_rect.set_fill_color(Color::green);
        win.set_label("Canvas #7");

        Text t{Point{150,150},"Hello, graphical world!"};
        win.attach(t);
        win.set_label("Canvas #8");

        t.set_font(Graph_lib::Font::times_bold);
        t.set_font_size(20);
        win.set_label("Canvas #9");

        ostringstream oss;
        oss << "screen size: " << x_max() << "*" << y_max()
            << "; window size: " << win.x_max() << "*" << win.y_max();
        Text sizes{Point{100,20},oss.str()};
        sizes.set_font_size(10);
        win.attach(sizes);

        win.wait_for_button();
      }
      catch(exception& e) {
        cerr << "Exception error " << e.what();
        return 1;
      }
      catch(...) {
        cerr << "Unknown expection";
        return 2;
      }
  #+end_src

   

* Calculator
   #+name: grammar
   #+begin_src C++ :main no :tangle calculator/calculator_v3.cpp
     /*
     Grammar

     Calculation:
       Statement
       Print
       Quit
       Help
       Calculation Statement

     Statement:
       Declaration
       Expression

     Print:
       ";"

     Quit:
       "q"

     Declaration:
       "let" Name "=" Expression
       "const" Name "=" Expression

     Name:
       letter
       letter Sequence

     Sequence:
       letter
       digit
       "-"
       letter Sequence
       digit Sequence
       "-" Sequence

     Expression:
       Term
       Expression "+" Term
       Expression "-" Term

     Term:
       Primary
       Term "*" Primary
       Term "/" Primary
       Term "%" Primary

     Primary:
       Number
       "(" Expression ")"
       "-" Primary
       "+" Primary
       "sqrt(" Expression ")"
       "pow(" Expression "," Integer ")"
       Name
       Name "=" Expression

     Number
       floating-point-literals

     */
    #+end_src


    #+name: header
    #+begin_src C++ :main no :tangle calculator/calculator_v3.cpp
      #include "../std_lib_facilities.h"

    #+end_src



    #+name: Constants
    #+begin_src C++ :main no :tangle calculator/calculator_v3.cpp
      const char let = 'L';
      const char con = 'C';
      const char quit = 'q';
      const char help = 'h';
      const char print = ';';
      const char number = '8';
      const char name = 'a';
      const char square_root = 's';
      const char power = 'p';
      const string declkey = "let";
      const string constkey = "const";
      const string sqrtkey = "sqrt";
      const string powkey = "pow";
      const string quitkey = "quit";
      const string helpkey = "help";
      const string prompt = "> ";
      const string result = "= ";

      // ------------------------------------------------------------ 

    #+end_src

    

    #+name: Class definitions
    #+begin_src C++ :main no :tangle calculator/calculator_v3.cpp
      class Token {
      public:
        char kind;
        double value;
        string name;
        Token(char ch) :kind{ch}, value{0} {}
        Token(char ch, double val) :kind{ch}, value{val} {}
        Token(char ch, string n) :kind{ch}, name{n} {}
      };

      class Token_stream {
      public:
        Token_stream();               // make Token_stream that reads from cin
        Token_stream(istream&);        // reads from istream
        Token get();
        void putback(Token t);
        void ignore(char c);          // discard characters up to and including 'c'
      private:
        bool full;
        Token buffer;
      };

      // Constructor
      Token_stream::Token_stream()
        :full{false}, buffer{0} {}

      // ------------------------------------------------------------

    #+end_src



    #+name: token_stream
    #+begin_src C++ :main no :tangle calculator/calculator_v3.cpp
      Token Token_stream::get()
      {
        if (full) {
          full = false;
          return buffer;
        }

        char ch;
        cin.get(ch);                  // cin.get does not skip white space
        while (isspace(ch)){
          if (ch=='\n') return Token{print};
          cin.get(ch);
        }

        switch (ch){
        case print:
        case '(': case ')':
        case '+': case '-': case '*': case '/': case '%':
        case '=':
        case ',':
          return Token{ch};
        case '.':
        case '0': case '1': case '2': case '3': case '4':
        case '5': case '6': case '7': case '8': case '9':
          {
            cin.putback(ch);
            double val;
            cin >> val;
            return Token{number,val};
          }
        default:
          if (isalpha(ch)) {
            string s;
            s += ch;
            while (cin.get(ch) && (isalpha(ch)||isdigit(ch)||ch=='_')) s+=ch;
            cin.putback(ch);
            if (s==declkey) return Token{let};
            if (s==constkey) return Token{con};
            if (s==sqrtkey) return Token{square_root};
            if (s==powkey) return Token{power};
            if (s==helpkey) return Token{help};
            if (s==quitkey) return Token{quit};
            return Token{name,s};
          }
          error("Bad Token");
        }
      }

      //---------------------------------------------------------------------

      void Token_stream::putback(Token t)
      {
        if (full) error("putback() into full buffer");
        buffer = t;
        full = true;
      }

      //---------------------------------------------------------------------

      void Token_stream::ignore(char c)
      // 'c' is kind of token
      {
        // look in buffer first
        if (full && c==buffer.kind) {
          full = false;
          return;
        }
        // if c is not equal to the kind of buffer
        // empty buffer
        full = false;

        char ch = 0;
        while (cin>>ch)
          if (ch==c) return;
      }
    #+end_src

    #+RESULTS: token_stream




    Variable is type for (name,value) pairs.
    Symbol_table is a container for Variable type.

    #+name: variables
    #+begin_src C++ :main no :tangle calculator/calculator_v3.cpp
      class Variable {
      public:
        string name;
        double value;
        bool is_const;
        Variable(string n, double v, bool c) :name{n}, value{v}, is_const{c} {}
      };

      //------------------------------------------------------------------------

      class Symbol_table {
      public:
        double get(string s);
        void set(string s, double d);
        bool is_declared(string s);
        double declare(string s, double d, bool b);
      private:
        vector<Variable> var_table;
      };

      //-------------------------------------------------------------------------

      double Symbol_table::get(string s)
      {
        for (const Variable& v : var_table)
          if (v.name==s) return v.value;
        error("get() undefined variable",s);
      }

      //-------------------------------------------------------------------------

      void Symbol_table::set(string s, double d)
      {
        for (Variable& v: var_table)
          if (v.name==s) {
            if (v.is_const) error(v.name," is a constant");
            v.value = d;
            return;
          }
        error("set() undefined variable ",s);
      }

      //---------------------------------------------------------------------------

      bool Symbol_table::is_declared(string s)
      {
        for (const Variable& v : var_table)
          if (v.name==s) return true;
        return false;
      }

      //---------------------------------------------------------------------------

      double Symbol_table::declare(string s, double d, bool b)
      {
        if (is_declared(s)) error(s, " declared already");
        var_table.push_back(Variable{s,d,b});
        return d;
      }

      //--------------------------------------------------------------------------

      Symbol_table st;
    #+end_src



    Grammar for Primary
     - Number
     - "(" Expression ")"
     - "-" Primary
     - "+" Primary
     - "sqrt(" Expression ")"
     - "pow(" Expression "," Integer ")"
     - Name
     - Name "=" Expression
 
    #+name: Primary
    #+begin_src C++ :main no :tangle calculator/calculator_v3.cpp
      double expression(Token_stream& ts);

      double primary(Token_stream& ts)
      {
        Token t = ts.get();
        switch (t.kind) {
        case '(':
          {
            double d = expression(ts);
            t = ts.get();
            if (t.kind!=')') error("')' expected");
            return d;
          }
        case '-':
          return -primary(ts);
        case '+':
          return primary(ts);
        case number:
          return t.value;
        case name:
          {
            Token t2 = ts.get();
            if (t2.kind=='='){
              double d = expression(ts);
              st.set(t.name,d);
              return d;
            }
            else {                    // not an assignment
              ts.putback(t2);
              return st.get(t.name);
            }
          }
        case square_root:
          {
            t = ts.get();
            if (t.kind!='(') error("'(' expected");
            double d = expression(ts);
            t = ts.get();
            if (t.kind!=')') error("')' exprected");
            return sqrt(d);
          }
        case power:
          {
            t = ts.get();
            if (t.kind!='(') error("'(' expected");
            double d = expression(ts);
            t = ts.get();
            if (t.kind!=',') error("',' expected");
            t = ts.get();
            if (t.kind!=number) error("second argumnet of pow() is not a numner");
            int i = int(t.value);
            if (i!=t.value) error("second argument of pow() is not an integer");
            t = ts.get();
            if (t.kind!=')') error("')' expected");
            return pow(d,i);
          }
        default:
          error("primary expected");
        }
      }

      //---------------------------------------------------------------------------
      
      #+end_src



      Grammar for Term
       - Primary
       - Term "*" Primary
       - Term "/" Primary
       - Term "%" Primary

    #+name: Term
    #+begin_src C++ :main no :tangle calculator/calculator_v3.cpp
            double term(Token_stream& ts)
            {
              double left = primary(ts);
              Token t = ts.get();

              while (true) {
                switch (t.kind) {
                case '*':
                  left *= primary(ts);
                  t = ts.get();
                  break;
                case '/':
                  {
                    double d = primary(ts);
                    if (d==0) error("division by 0");
                    left /= d;
                    t = ts.get();
                    break;
                  }
                case '%':
                  {
                    double d = primary(ts);
                    if (d==0) error("division by 0");
                    left = fmod(left,d);
                    t = ts.get();
                    break;
                  }
                default:
                  ts.putback(t);
                  return left;
                }
              }
            }

      //-----------------------------------------------------------------------------
     
      #+end_src



      Grammar for Expression
       - Term
       - Expression "+" Term
       - Expression "-" Term

      #+name: Expression
      #+begin_src C++ :main no :tangle calculator/calculator_v3.cpp
        double expression(Token_stream& ts)
        {
          double left = term(ts);
          Token t = ts.get();

          while (true) {
            switch (t.kind) {
            case '+':
              left += term(ts);
              t = ts.get();
              break;
            case '-':
              left -= term(ts);
              t = ts.get();
              break;
            case '=':
              error("use '=' outside of declaration");
            default:
              ts.putback(t);
              return left;
            }
          }
        }

        // ------------------------------------------------------------

    #+end_src


    Grammar for Declaration
     - "let" Name "=" Expression
     - "const" Name "=" Expression
     =double Symbol_table::declare(string s, double d, bool b)= for varible keeping in =Symbol_table st=.
     =bool b= is =true= for =const=, =false= for =let=.
 
       #+name: Declaration
       #+begin_src C++ :main no :tangle calculator/calculator_v3.cpp
         double declaration(bool b, Token_stream& ts)
         {
           Token t = ts.get();
           if (t.kind!=name) error("name expected in declaration");
           string var_name = t.name;

           Token t2 = ts.get();
           if (t2.kind!='=') error("= missing in declaration of ", var_name);

           double d = expression(ts);
           st.declare(var_name,d,b);

           return d;
         }

         // ------------------------------------------------------------
       #+end_src


    Grammar for Statement
     - Declaration
     - Expression
    
       #+name: Statement
       #+begin_src C++ :main no :tangle calculator/calculator_v3.cpp
         double statement(Token_stream& ts)
         {
           Token t = ts.get();
           switch (t.kind) {
           case let:
             return declaration(false,ts);
           case con:
             return declaration(true,ts);
           default:
             ts.putback(t);
             return expression(ts);
           }
         }

         // ------------------------------------------------------------
       #+end_src



     #+name: Help functions
     #+begin_src C++ :main no :tangle calculator/calculator_v3.cpp
       // clean input after error
       void clean_up_mess(Token_stream& ts)
       {
         ts.ignore(print);
       }

       // ------------------------------------------------------------

       void print_help()
       {
         cout << "Instructions: enter expressions, there are\n"
              << "a few functions, you can declare variables using\n"
              << " the 'let' keyword and constants with the 'const'\n"
              << "keyword."
              << endl;
       }

       // ------------------------------------------------------------
     #+end_src
    Grammar for Calculation
     - Statement
     - Print
     - Quit
     - Help
     - Calculation Statement

       #+name: Calculate
       #+begin_src C++ :main no :tangle calculator/calculator_v3.cpp
         void calculate()
         {
           Token_stream ts;
           while (cin) 
             try {
               cout << prompt;
               Token t = ts.get();
               while (t.kind==print) t = ts.get(); // first discard all "prints"
               if (t.kind==help) print_help();
               else {
                 if (t.kind==quit) return;
                 ts.putback(t);
                 cout << result << statement(ts) << endl;
               }
             }
             catch(exception& e) {
               cerr << e.what() << endl;
               clean_up_mess(ts);
             }
         }

         // ------------------------------------------------------------
       #+end_src




     #+name: main
     #+begin_src C++ :main no :tangle calculator/calculator_v3.cpp
       int main()
         try {
           st.declare("pi",3.1415926535,true);
           st.declare("e",2.7182818284,true);
           st.declare("k",1000,true);

           calculate();

           return 0;
         }
         catch (exception& e) {
           cerr << "exception: " <<e.what() << endl;
           char c;
           while (cin>>c && c!=';');
           return 1;
         }
         catch(...) {
           cerr << "exception\n";
           char c;
           while (cin>>c && c!=';');
           return 2;
         }
     #+end_src

     #+RESULTS: main
     : 10 values in fibonacci
     : {1, 2, 3, 5, 8, 
     : 13, 21, 34, 55, 89}




   

