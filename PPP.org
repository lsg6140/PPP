* Header file
  #+begin_src C++ :tangle ./std_lib_facilities.h :main no
    #ifndef H112
    #define H112 020215L

    #include<iostream>
    #include<iomanip>
    #include<fstream>
    #include<sstream>
    #include<cmath>
    #include<cstdlib>
    #include<string>
    #include<list>
    #include<forward_list>
    #include<vector>
    #include<unordered_map>
    #include<algorithm>
    #include<array>
    #include<regex>
    #include<random>
    #include<stdexcept>

    using Unicode = long;

    using namespace std;

    struct Exit : runtime_error {
      Exit() : runtime_error("Exit"){}
    };

    inline void error(const string& s)
    {
      throw runtime_error(s);
    }

    inline void error(const string& s1, const string& s2)
    {
      error(s1+s2);
    }

    inline void error(const string& s, int i)
    {
      ostringstream os;
      os << s << ": " << i;
      error(os.str());
    }

    #endif //H112
  #+end_src

* Ch 6
*** Strategy
  - What should the program do in the user's point of view?
  - Try breaking the program into manageable parts.
  - Build a small, limited version of the program that solves a key part
*** Prototype
    - Expression: 2+2
      Result: 4
    - Expression: 2+2*3
      Result: 8
    - Logic of the program
      read_a_line
      calculate
      write_result
    - To compile the code block, tangle the code block and compile with
      ~SPC c C~ ~$ g++ ch6_1.cpp -std=c++14~.
      After compile, run the program in shell by
      ~SPC !~.
    #+begin_src C++ :includes " \"std_lib_facilities.h\" " :tangle tangled/ch6_1.cpp 
      cout<<"Expression: ";
      int lval = 0;
      int rval;
      char op;
      int res;
      cin>>lval>>op>>rval;  // read something like 1+3

      if (op=='+')
        res = lval+rval;  // addition
       else if(op=='-')
         res = lval-rval;  // subtraction

      cout<<"Result: "<<res<<'\n';
    #+end_src
*** Second version
    - Add multiplication and division
    - More than one operand (e.g. 1+2+3)
    - ~switch~: testing a value agianst many constants
    #+begin_src C++ :includes " \"std_lib_facilities.h\" " :tangle tangled/ch6_2.cpp
      cout<<"Expression\n";
      cout<<"add an 'x' to end expression: ";
      int lval = 0;
      int rval;
      cin>>lval;
      if(!cin) error("no first operand");
      for (char op;cin>>op;){
        if(op!='x') cin>>rval;
        if(!cin) error("no second operand");
        switch(op){
        case '+':
          lval+=rval;
          break;
        case '-':
          lval-=rval;
          break;
        case '*':
          lval*=rval;
          break;
        case '/':
          lval/=rval;
          break;
        default:
          cout<<"Result :"<<lval<<'\n';
          return 0;

        }

       }
      error("bad expression");

    #+end_src
*** Tokens
    A token is a sequence of characters that presents something we consider a unit.
    Kinds of tokens:
    - Floating-point-literals
    - Operators
    - Parentheses
*** Grammar
    Define the syntax of our input. Program implements the rules of grammar.
    - Expression:
       Term
       Expression "+" Term
       Expression "-" Term
    - Term:
       Primary
       Term "*" Primary
       Term "/" Primary
       Term "%" Primary
    - Primary
       Number
       "(" Expression ")"
    - Number
       Floating-point-literal
*** Turning a grammar into code
    We need four functions
    - ~get_token()~: read characters and compose tokens using ~cin~
    - ~expression()~: deal with + and -, calls ~term()~ and ~get_token()~
    - ~term()~: deal with *, /, and %, calls ~primary()~ and ~get_token()~
    - ~primary()~: deal with numbers and parentheses, calls ~expression()~ and ~get_token()~
    Token
    #+name: token
    #+begin_src C++ :main no
      class Token {
      public:
        char kind;
        double value;
        string name;
        Token()
          : kind{0} {}
        Token(char ch)
          :kind{ch}, value{0} {}
        Token(char ch, double val)
          :kind{ch}, value{val} {}
        Token(char ch, string n)
          :kind{ch}, name{n} {}
      };

      //--------------------------------------------------------

      class Token_stream {
      public:
        Token_stream();
        Token get();
        void putback(Token t);
        void ignore(char c);
      private:
        bool full;
        Token buffer;
      };

      //--------------------------------------------------------

      Token_stream::Token_stream()
        :full(false), buffer(0){}

      //--------------------------------------------------------

      void Token_stream::putback(Token t)
      {
        if (full) error("putback() into a full buffer");
        buffer = t;
        full = true;
      }

      //--------------------------------------------------------

      void Token_stream::ignore(char c)
      {
        if (full&&c==buffer.kind) {
          full = false;
          return;
        }
        full = false;

        char ch = 0;
        while (cin>>ch)
          if (ch==c) return;
      }

      // -------------------------------------------------------

      const char name = 'a';          // name token
      const char let = 'L';           // declaration token
      const string declkey = "let";   // declaration keyword

      //-------------------------------------------------------

      Token Token_stream::get()
      {
        if (full) {
          full = false;
          return buffer;
        }

        char ch;
        cin >> ch;

        switch (ch) {
        case quit:
        case print:
        case '(': case ')':
        case '+': case '-':
        case '*': case '/': case '%':
        case '=':
         return Token{ch};
        case '0': case '1': case '2': case '3': case '4':
        case '5': case '6': case '7': case '8': case '9':
          {
            cin.putback(ch);
            double val;
            cin >> val;
            return Token{number,val};
          }
        default:
          if (isalpha(ch)){
            string s;
            s += ch;
            while (cin.get(ch)&&(isalpha(ch)||isdigit(ch))) s+=ch;
            cin.putback(ch);
            if (s==declkey) return Token{let};
            return Token{name,s};
          }
          error("Bad Token");
        }
      }
    #+end_src
    #+name: clean-up-mess
    #+begin_src C++ :main no
      void clean_up_mess()
      {
        ts.ignore(print);
      }
    #+end_src
    Expressions
    #+name: expression
    #+begin_src C++ :main no
      double expression()
      {
        double left = term();
        Token t = ts.get(); 
        while (true){
          switch (t.kind){
          case '+':
            left += term();
            t = ts.get();
            break;
          case '-':
            left -= term();
            t = ts.get();
            break;
          default:
            ts.putback(t);
            return left;
          }
        }
      }
    #+end_src
    Term
    #+name: term
    #+begin_src C++ :main no
      double term()
      {
        double left = primary();
        Token t = ts.get();
        while (true){
          switch (t.kind){
          case '*':
            left *= primary();
            t = ts.get();
            break;
          case '/':{
            double d = primary();
            if (d==0) error("divide by zero");
            left /= d;
            t = ts.get();
            break;
          }
          case '%': {
            double d = primary();
            if (d==0) error("%: divide by zero");
            left = fmod(left,d);
            t = ts.get();
            break;
          }
          default:
            ts.putback(t);
            return left;
          }
        }
      }
    #+end_src
    Primary
    #+name: primary
    #+begin_src C++ :main no
      double primary()
      {
        Token t = ts.get();
        switch (t.kind){
        case '(':{
          double d = expression();
          t = ts.get();
          if (t.kind!=')') error("')' expected");
          return d;
        }
        case number:
          return t.value;
        case name:
          return get_value(t.name);
        case '-':
          return -primary();
        case '+':
          return primary();
        default:
          error("primary expected");
        }
      }
    #+end_src


    #+name: calculator_v0
    #+begin_src C++ :tangle tangled/calculator_v0.cpp :main no :noweb yes
      #include "std_lib_facilities.h"

      <<token>>

      double expression();

      <<primary>>

      <<term>>

      <<expression>>

      int main()
      {
        double val = 0;
        while (cin) {
          Token t = ts.get();
          if (t.kind=='q') break;
          if (t.kind==';')
            cout<<"="<<val<<'\n';
          else
            ts.putback(t);
          val = expression();
        }
      }
    #+end_src

    #+RESULTS: calculator_v0
* Ch 7
  CLOSED: [2019-02-14 Thu 13:26] DEADLINE: <2019-02-14 Thu 12:00> SCHEDULED: <2019-02-14 Thu 09:00>
  #+name: calculate
  #+begin_src C++ :main no
    void calculate()
    {
      while (cin){
        try{
          cout << prompt;
          Token t = ts.get();
          while (t.kind==print) t = ts.get(); // first discard all "prints"
          if (t.kind==quit) return;
          ts.putback(t);
          cout << result << statement() << '\n';
        }
        catch (exception& e) {
          cerr<<e.what()<<'\n';
          clean_up_mess();
        }
      }
    }
  #+end_src
  #+name: variable
  #+begin_src C++ :main no
    class Variable {
    public:
      string name;
      double value;
    };

    vector<Variable> var_table;

    //----------------------------------

    double get_value(string s)
    {
      for (const Variable& v : var_table)
        if (v.name==s) return v.value;
      error("get: undefined variable ", s);
    }

    //-----------------------------------

    void set_value(string s, double d)
    {
      for(Variable& v: var_table)
        if(v.name==s) {
          v.value = d;
          return;
        }
      error("set: undefined variable ",s);
    }
  #+end_src
  #+name: statement
  #+begin_src C++ :main no
    double statement()
    {
      Token t = ts.get();
      switch (t.kind) {
      case let:
        return declaration();
      default:
        ts.putback(t);
        return expression();
      }
    }
  #+end_src
  #+name: declaration
  #+begin_src C++ :main no
    bool is_declared(string var)
    {
      for (const Variable& v : var_table)
        if (v.name==var) return true;
      return false;
    }

    //------------------------------------

    double define_name(string var, double val)
    {
      if (is_declared(var)) error(var," declared twice");
      var_table.push_back(Variable{var,val});
      return val;
    }

    //-------------------------------------

    double declaration()
    {
      Token t = ts.get();
      if (t.kind!=name) error("name expected in declaration");
      string var_name = t.name;

      Token t2 = ts.get();
      if (t2.kind!='=') error("=missing in declaration of ",var_name);

      double d = expression();
      define_name(var_name,d);
      return d;
    }
  #+end_src
  #+name: calculator-v1
  #+begin_src C++ :main no :tangle tangled/calculator-v1.cpp :noweb yes
    #include "std_lib_facilities.h"

    // --------------------------------------

    const char number = '8';        // t.kind==number means t is a number Token
    const char quit = 'q';
    const char print = ';';
    const string prompt = "> ";
    const string result = "= ";

    // --------------------------------------

    <<token>>

    Token_stream ts;

    <<clean-up-mess>>

    <<variable>>

    double expression();

    <<primary>>

    <<term>>

    <<expression>>

    <<declaration>>

    <<statement>>

    <<calculate>>

    int main()
    try
      {
        calculate();
        return 0;
      }
     catch (exception& e) {
       cerr<<e.what()<<'\n';
       return 1;
     }

     catch (...) {
       cerr<<"exception\n";
       return 2;
     }
  #+end_src
* Ch 8
** Summary
  - A declaration is a statement that introduces a name into a scope
  - A definition is a declaration that fully specifies the entity declared
  - A definition of a variable set aside memory so can't be defined twice
  - A declaration simply tells how a that name can be used
  - A declaration is just an interface and doesn't allocate memory
  - Something can be declared as often as you like if it's done consistently
  #+begin_src C++
    int x = 7;                      // definition
    extern int x;                   // declaration
    extern int x;                   // another declaration

    double sqrt(double);            // declaration
    double sqrt(double) {/*...*/};   // definition
    double sqrt(double);            // another declaration

    int sqrt(double);               // error!! inconsistency
  #+end_src

  #+RESULTS:

  - ~extern~ keyword states that declaration of ~x~ is not a definition
  - Avoid using ~extern~
  - A declaration supplies the type
  - A definition supplies the object (the memory)
  - A header should only contain declarations that can be duplicated in several files
  - ~(a>=b)?a:b~ is ~a~ if ~a>=b~ and ~b~ otherwise
  - Try to avoid class in function
  - Function within function is not allowed
  - Pass-by-const-reference: ex) ~const vector<double>& v~
  - Pass-by-reference: ex) ~vector<double>& v~
  - Technical point of reference
  #+begin_src C++ :main no
    #include <iostream>

    int main()
    {
      int i = 7;
      int& r = i;                   // r is a reference to i
      r = 9;                        // i becomes 9
      i = 10;
      std::cout << r << ' ' << i << '\n'; // write: 10 10
    }
  #+end_src

  #+RESULTS:
  : 10 10
  - Any use of ~r~ is a use of ~i~
  - Reference can be a convenient shorthand for some object
  - ~double& var = v[f(x)][g(y)];~
  - Non-const-reference is essential in
    - manipulating containers and other large objects
    - for functions that change several objects (function can have only one return value)
  - Argumnet checking and conversion
  #+begin_src C++ :main no
    #include <iostream>

    int main()
    {
      double x = 1.2;
      int x1 = x;                   // truncate x
      int x2 = int(x);
      int x3 = static_cast<int>(x); // explicit conversion

      std::cout << "x1 = " << x1 << ", x2 = " << x2
                << " ,x3 = " << x3 << std::endl;

      return 0;
    }
  #+end_src

  #+RESULTS:
  | x1 = 1 | x2 = 1 | x3 = 1 |
  - constexpr functions: evaluated by the compiler to avoid the same calculation done millions of times at run time
  - A constexpr function with constexpr arguments is evaluated by compiler
  - Construct the ~Date~ once only
  #+begin_src C++ 
    const Date& default_date()
    {
      static const Date dd(1970,1,1);
      return dd;
    }
  #+end_src
  - The ~static~ local variable is initialized only the first time its function is called
** Exercise
*** Drill 1
   #+name: my.h
   #+begin_src C++ :main no :tangle tangled/my.h
     extern int foo;
     void print_foo();
     void print(int);
   #+end_src
   #+name: my.cpp
   #+begin_src C++ :main no :tangle tangled/my.cpp
     #include "my.h"
     #include "std_lib_facilities.h"

     int foo;
     void print_foo()
     {
       cout << foo << endl;
     }

     void print(int i)
     {
       cout << i << endl;
     }
   #+end_src
   #+name: use.cpp
   #+begin_src C++ :main no :tangle tangled/use.cpp
     #include "my.h"

     int main()
     {
       foo = 7;
       print_foo();

       print(99);
     }
   #+end_src

*** Drill 2
    #+name: d2
    #+begin_src C++ :main no :tangle tangled/d2.cpp
      #include "std_lib_facilities.h"

      void swap_v(int a, int b)
      {
        int temp;
        temp = a;
        a = b;
        b = temp;
      }

      void swap_r(int& a, int& b)
      {
        int temp;
        temp = a;
        a = b;
        b = temp;
      }

      /*
      void swap_cr(const int& a, const int& b)
      {
        int temp;
        temp = a;
        a = b;
        b = temp;
      } */

      int main()
      {
        int x = 7;
        int y = 9;
        swap_v(x,y);
        cout << "x= " << x << ", y= " << y <<endl;
        swap_v(7,9);
        swap_r(x,y);
        cout << "x= " << x << ", y= " << y << endl;
        // swap_r(7,9); not compiled
        double xx = 7;
        double yy = 9;
        swap_v(xx,yy);
        // swap_r(xx,yy); not compiled
        cout << "xx= " << xx << ", yy= " << yy << endl;
      }
    #+end_src
    
*** Drill 3
    #+name: d3.cpp 
    #+begin_src C++ :main no :tangle tangled/d3.cpp
      #include "std_lib_facilities.h"

      namespace X {
        int var;
        void print() {
          cout << var << endl;
        }
      }

      namespace Y {
        int var;
        void print()
        {
          cout << var << endl;
        }
      }

      namespace Z {
        int var;
        void print()
        {
          cout << var << endl;
        }
      }

      int main()
      {
        X::var = 7;
        X::print();
        using namespace Y;
        var = 9;
        print();
        {
          using Z::var;
          using Z::print;
          var = 11;
          print();
        }
        print();
        X::print();
      }
    #+end_src
*** Ex 1
 
* Ch 9
** Summary
   - Types are helpful in
    - Representation: A type "knows" how to represent the data needed in an object
    - Operations: A type "knows" what operations can be applied to objects
   - The result of the operation depends on the data - the current state - of an object
   - User-defined types of C++
    - Class
    - Enumeration
   - Members: The parts used to define the class
   - ~m~ in ~mf(int)~ refers to ~var.m~
   #+begin_example
     class X {
     public:
       int m;
       int mf(int v) {int old = m; m = v; return old}
     };
   #+end_example
   - Interface is that its users access directly (~public:~)
   - Implementation is that its users access only indirectly through the interface (~private:~)
   - ~struct~ is a class where members are public by default
   - A member function with the same name as its class is the constructor
   - From C++11, ~{}~ is prefered than ~()~
   - A rule for what constitutes a valid value is called and /invariant/
   - If we can't think of a good variant, we are probably dealing with plain data and better to use a =stuct=
   - Definition of a member function within the class definition
     - The function will be inline
   - A class member function has an implicit argument which is uses to identify the object for which is is called
   - An =enum= is a very simple user-defined type, specifying its set of values as symbolic constants
   - We can assign an object to an int in plain enumeration
   - Plain =enum= is less strict than =enum class=
   - Prefer to use =enum class=
   - Operator overloading: +,-,*,/,%,[],(),^,!,&,<,<=,>,>=
   - Class interfaces
     - Keep interface complete
     - Keep interface minimal
     - Provide constructor
     - Support copying
     - Use type to provide good argument checking
     - Identify nonmodifying member functions
     - Free all resources in the destructor
   - In-class initializer: specified as part of the memeber declaration
   - Operations that do not modify the object can be invoked for =const= objects
   - Helper function is a design concept, not a programming language concept
   - Namespaces are often used to identify a group of helper functions
*** Date class 
    #+name: chrono.h
    #+begin_src C++ :main no :tangle tangled/chrono.h
      namespace Chrono {
        enum class Month {
                          Jan=1,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec
        };

        class Date {
        public:
          class Invalid();              // to be used as exception
          Date(int y, Month m, int d);
          Date();                       // default constructor
          Date(int y);

          // nonmodifying operations
          int month() const {return m;}
          int day() const {return d;}
          int year() const {return y;}

          // modifying operations
          void add_day(int n);
          void add_month(int n);
          void add_year(int n);
        private:
          int y;
          Month m;
          int d;
        };

        //------------------------------------------------------------

        void init_day(Date& dd, int y, int m, int d);

        //------------------------------------------------------------

        bool is_date(int y,Month m,int d);

        //------------------------------------------------------------

        bool leapyear(int y);

        //------------------------------------------------------------

        bool operator==(const Date& a,const Date& b);
        bool operator!=(const Date& a,const Date& b);

        ostream& operator<<(ostream& os,const Date& d);
        istream& operator>>(istream& is, Date& dd);

        //------------------------------------------------------------

        Day day_of_week(const Date& d);
        Date next_Sunday(const Date d);
        Date next_weekday(const Date& d);
      }

    #+end_src

    #+name: chrono.c
    #+begin_src C++ :main no :tangle tangled/chrono.cpp
      #include "chrono.h"

      namespace Chrono {
        // construtors
        Date::Date(int yy,Month mm,int dd)
          :y{yy},m{mm},d{dd}
        {
          if (!is_date(yy,mm,dd)) throw Invalid{};
        }

        const Date& default_date()
        {
          static Date dd{2001,Month::Jan,1};
          return dd;
        }

        Date::Date()
          :y{default_date().year()},
           m{default_date().month()},
           d{defualt_date(),day()}
        {}

        // member functions

        void Date::add_day(int n)
        {
          //...
        }

        void Date::add_month(int n)
        {
          // ...
        }

        void Date::add_year(int n)
        {
          if (m==Month::Feb&&d==29&&!leapyear(y+n)){
            m = Month::mar;
            d = 1;
          }
          y += n;
        }

        // helper functions

        bool is_date(int y,Month m,int d)
        {
          if (d<=0) return false;
          if (m<Month::Jan||Month::Dec<m) return false;

          int days_in_month = 31;

          switch (m){
          case Month::Feb:
            days_in_month = (leapyear(y))? 29:28;
            break;
          case Month::Apr: case Month::Jun: case Month::Sep: case Month::Nov:
            days_in_month = 30;
            break;
          }

          if (days_in_month<d) return false;

          return true;
        }

        // ------------------------------------------------------------

        bool leapyear(int y)
        {
          // ...
        }

        // ------------------------------------------------------------

        bool operator==(const Date& a,const Date& b)
        {
          return a.year()==b.year()&&a.month()==b.month()&&a.day()==b.day();
        }

        bool operator!=(const Date& a,const Date& b)
        {
          return !(a==b);
        }

        ostream& operator<<(ostream& os,const Date& d)
        {
          return os<<'('<<d.year()
                   <<','<<int(d.month())
                   <<','<<d.day()<<')';
        }

        istream& operator>>(istream& is,const Date& dd)
        {
          int y, m, d;
          char ch1, ch2, ch3, ch4;
          is>>ch1>>y>>ch2>>m>>ch3>>d>>ch4;
          if (!is) return is;
          if (ch1!='('||ch2!=','||ch3!=','||ch4!=')'){
            is.clear(ios_base::failbit);
            return is;
          }

          dd = Date{y,Month{m},d};

          return is;
        }

        // ------------------------------------------------------------

        enum class Day {
                        Sun,Mon,Tue,Wed,Thu,Fri,Sat
        };

        Day day_of_week(const Date& d)
        {
          // ...
        }

        // ------------------------------------------------------------

        Date next_Sunday(const Date& d)
        {
          // ...
        }

        // ------------------------------------------------------------

        Date next_weekday(const Date& d)
        {
          // ...
        }
      } // Chrono
    #+end_src
* Calculator
   #+name: grammar
   #+begin_src C++ :main no :tangle tangled/calculator_v3.cpp
     /*
     Grammar

     Calculation:
       Statement
       Print
       Quit
       Help
       Calculation Statement

     Statement:
       Declaration
       Expression

     Print:
       ";"

     Quit:
       "q"

     Declaration:
       "let" Name "=" Expression
       "const" Name "=" Expression

     Name:
       letter
       letter Sequence

     Sequence:
       letter
       digit
       "-"
       letter Sequence
       digit Sequence
       "-" Sequence

     Expression:
       Term
       Expression "+" Term
       Expression "-" Term

     Term:
       Primary
       Term "*" Primary
       Term "/" Primary
       Term "%" Primary

     Primary:
       Number
       "(" Expression ")"
       "-" Primary
       "+" Primary
       "sqrt(" Expression ")"
       "pow(" Expression "," Integer ")"
       Name
       Name "=" Expression

     Number
       floating-point-literals

     */
    #+end_src

    #+name: token-definition
    #+begin_src C++ :main no :tangle tangled/calculator_v3.cpp
      #include "std_lib_facilities.h"

      class Token {
      public:
        char kind;
        double value;
        string name;
        Token(char ch) :kind{ch}, value{0} {}
        Token(char ch, double val) :kind{ch}, value{val} {}
        Token(char ch, string n) :kind{ch}, name{n} {}
      };

      class Token_stream {
        Token_stream();               // make Token_stream that reads from cin
        Token_stream(istream&);        // reads from istream
        Token get();
        void putback(Token t);
        void ignore(char c);          // discard characters up to and including 'c'
      private:
        bool full;
        Token buffer;
      };

      // Constructor
      Token_stream::Token_stream()
        :full{false}, buffer{0} {}

      const char let = "L";
      const char con = "C";
      const char quit = "q";
      const char help = "h";
      const char print = ";";
      const char number = "8";
      const char name = "a";
      const char square_root = "s";
      const char power = "p";
      const string declykey = "let";
      const string conkey = "con";
      const string sqrtkey = "sqrt";
      const string powkey = "pow";
      const string quitkey = "quit";
      const string helpkey = "help";
    #+end_src
    
    #+name: token_stream
    #+begin_src C++ :main no :tangle tangled/calculator_v3.cpp
      Token Token_stream::get()
      {
        if (full) {
          full = false;
          return buffer;
        }

        char ch;
        cin.get(ch);                  // cin.get does not skip white space
        while (isspace(ch)){
          if (ch=='\n') return Token{print};
          cin.get(ch);
        }

        switch (ch){
        case print:
        case '(', case ')':
        case '+', case '-', case '*', case '/', case '%':
        case '=':
        case ',':
          return Token{ch};
        case '.':
        case '0', case '1', case '2', case '3', case '4'
        case '5', case '6', case '7', case '8', case '9':
          {
            cin.putback(ch);
            double val;
            cin >> val;
            return Token{number,val};
          }
        default:
          if (isalpah(ch)) {
            string s;
            s += ch;
            while (cin.get(ch) && (isalpha(ch)||isdigit(ch)||ch=='_')) s+=ch;
            cin.putback(ch);
            if (s==declkey) return Token{let};
            if (s==conkey) return Token{con};
            if (s==sqrtkey) return Token{square_root};
            if (s==powkey) return Token{power};
            if (s==helpkey) return Token{help};
            if (s==quitkey) return Token{quit};
            return Token{name,s};
          }
          error("Bad Token");
        }
      }

      //---------------------------------------------------------------------

      void Token_stream::putback(Token t)
      {
        if (full) error("putback() into full buffer");
        buffer = t;
        full = true;
      }

      //---------------------------------------------------------------------

      void Token_stream::ignore(char c)
      // 'c' is kind of token
      {
        // look in buffer first
        if (full & c==buffer.kind) {
          full = false;
          return;
        }
        // if c is not equal to the kind of buffer
        // empty buffer
        full = false;

        char ch = 0;
        while (cin>>ch)
          if (ch==c) return;
      }
    #+end_src

    #+name: variables
    #+begin_src C++ :main no
      class Variable {
      public:
        string name;
        double value;
        bool is_const;
        Variable(string n, double v, bool c) :name{n}, value{v}, is_const{c} {}
      };

      //------------------------------------------------------------------------

      class Symbol_table {
      public:
        double get(string s);
        void set(string s, double d);
        bool is_declared(string s);
        double declare(string s, double d, bool b);
      private:
        vector<Variable> var_table;
      };

      //-------------------------------------------------------------------------

      double Symbol_table::get(string s)
      {
        for (const Variable& v : var_table)
          if (v.name==s) return v.value;
        error("get() undefined variable",s);
      }

      //-------------------------------------------------------------------------

      void Symbol_table::set(string s, double d)
      {
        for (Variable& v: var_table)
          if (v.name==s) {
            v.value = d;
            return;
      S    }
        error("set() undefined variable ",s);
      }

      //---------------------------------------------------------------------------

      bool Symbol_table::is_declared(string s)
      {
        for (const Variable& v : var_table)
          if (v.name==s) return true;
        return false;
      }

      //---------------------------------------------------------------------------

      double Symbol_table::declare(string s, double d, bool b)
      {
        if (is_declare(s)) error(s, "declared already");
        var_table.push_back(Variable{s,d});
        return d;
      }

      //--------------------------------------------------------------------------

      Symbol_table st;
    #+end_src

    #+name: expression
    #+begin_src C++ :main no :tangle tangled/calculator_v3.cpp
      double expression(Token_stream& ts);

      double primary(Token_stream& ts)
      {
        Token t = ts.get();
        switch (t.kind) {
        case '(':
          {
            double d = expression(ts);
            t = ts.get();
            if (t.kind!=')') error("')' expected");
            return d;
          }
        case '-':
          return -priamry(ts);
        case '+':
          return primary(ts);
        case number:
          return t.value;
        case name:
          {
            Token t2 = ts.get();
            if (t2=='='){
              double d = expression(ts);
              st.set(t.name,d);
              return d;
            }
            else {                    // not an assignment
              ts.putback(t2);
              return st.get(t.name);
            }
          }
        case square_root:
          {
            t = ts.get();
            if (t.kind!='(') error("'(' expected");
            double d = expression(ts);
            t = ts.get();
            if (t.kind!=')') error("')' exprected");
            return sqrt(d);
          }
        case power:
          {
            t = ts.get();
            if (t.kind!='(') error("'(' expected");
            double d = expression(ts);
            t = ts.get();
            if (t.kind!=',') error("',' expected");
            t = ts.get();
            if (t.kind!=number) error("second argumnet of pow() is not a numner");
            int i = int(t.value);
            if (i!=t.value) error("second argument of pow() is not an integer");
            t = ts.get();
            if (t.kind!=')') error("')' expected");
            return pow(d,i);
          }
        default:
          error("primary expected");
        }
      }

      //---------------------------------------------------------------------------

      double term(Token_stream& ts)
      {
        double left = primary(ts);
        Token t = ts.get();

        while (true) {
          switch (t.kind) {
          case '*':
            left *= primary(ts);
            t = ts.get();
            break;
          case '/':
            {
              double d = primary(ts);
              if (d==0) error("division by 0");
              left /= d;
              t = ts.get();
              break;
            }
          case '%':
            {
              double d = primary(ts);
              if (d==0) error("division by 0");
              left %= d;
              t = ts.get();
              break;
            }
          default:
            ts.putback(t);
            return left;
          }
        }
      }

      //-----------------------------------------------------------------------------

      double expression(Token_stream& ts)
      {
        double left = term(ts);
        Token t = ts.get();

        while (true) {
          switch (t.kind) {
          case '+':
            left += term(ts);
            t = ts.get();
            break;
          case '-':
            left -= term(ts);
            t = ts.get();
            break;
          case '=':
            error("use '=' outside of declaration");
          defualt:
            ts.putback(t);
            return left;
          }
        }
      }
    #+end_src
